<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reset.css" />
  <link rel="stylesheet" href="css/reveal.css" />
  <link rel="stylesheet" href="css/theme/blood.css" />

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/monokai-sublime.css" />

  <!-- My custom css -->
  <link rel="stylesheet" href="css/custom.css" />

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement("link");
    link.rel = "stylesheet";
    link.type = "text/css";
    link.href = window.location.search.match(/print-pdf/gi)
      ? "css/print/pdf.css"
      : "css/print/paper.css";
    document.getElementsByTagName("head")[0].appendChild(link);
  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section data-markdown class="center">
        <textarea data-template>
              # Assembler x86 i x86-64
              #### Łukasz Gut, Grzegorz Litarowicz
            </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Agenda
                ---
                  - Co to jest Assembly i Assembler?
                  - Rodzaje Assembly i Assemblerów
                  - Hello, world!
                  - Proces kompilacji 
                  - Podstawy składni
                  - Krótko o segmentach pamięci
                  - Krótko o rejestrach
                  - Tryby adresowania
                  - Deklarowanie zmiennych oraz stałych
                  - Arytmetyka
                  - Operatory logiczne
                  - Instrukcje warunkowe
                  - Pętle
                  - Tablice
                  - Procedury
                  - Analiza mikro optymalizacji robionych przez kompilator
        </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Co to jest Assembly i Assembler
                ---
                **Assembly** - niskopoziomowy język programowania silnie skorelowany z architekturą procesora i instrukcjami rozumianymi przez ten procesor.
                **Assembler** - program komputerowy przekształcający instrukcje napisane w niskopoziomowym języku assembly w kod maszynowy.
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Rodzaje Assembly i Assemblerów
                ---
                Istnieje wiele rodzajów assembly, między innymi:
                - x86 assembly
                - x86-64 assembly
                - ARM assembly
                - i więcej  ...

                Istnieje także wiele rodzajów assemblerów, między innymi:
                - NASM
                - GNU Assembler
                - MASM
                - i więcej ...
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Hello, world!
                ---
                ```x86asm
                section	.text
                global _start     
              
                _start:	          
                   mov	edx,len   
                   mov	ecx,msg   
                   mov	ebx,1     
                   mov	eax,4     
                   int	0x80      
                
                   mov	eax,1     
                   int	0x80      

                section	.data
                msg db 'Hello, world!', 0xa 
                len equ $ - msg    
                ```
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Proces kompilacji
                ---
                Aby skompilować i zlinkować assembly w wykorzystaniem assemblera NASM i linkera GNU wpisujemy następujące komendy:
                ```sh
                nasm -f elf hello.asm #tworzenie pliku obiektowego
                ld -m elf_i386 -s -o hello hello.o #linkowanie
                ```
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Podstawy składni - sekcje
                ---
                Program w assembly dzieli się na 3 sekcje:
                - **data**
                - **bss**
                - **text**
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Podstawy składni - sekcja data
                ---
                Sekcja **data** jest wykorzystywana do deklarowania zainicjalizowanych stałych. Dane w tej sekcji 
                nie zmieniają się w trakcie działania programu.

                Deklaracja sekcji data wygląda następująco:
                ```x86asm
                section.data
                ```
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Podstawy składni - sekcja bss
                ---
                Sekcja **bss** jest wykorzystywana do deklarowania zmiennych.

                Deklaracja sekcji bss wygląda następująco:
                ```x86asm
                section.bss
                ```
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Podstawy składni - sekcja text
                ---
                Sekcja **text** jest wykorzystywana do trzymania kodu programu. Sekcja ta musi zaczynać się deklaracją *global _start*, która
                mówi kernelowi gdzie rozpocząć wykonywanie programu.

                Deklaracja sekcji text wygląda następująco:
                ```x86asm
                section.text
                  global _start
                _start:
                ```
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Podstawy składni - polecenia
                ---
                Polecenia w języku assembly wprowadzamy po jednym na linię. Każde polecenie ma następujący format:
                ```sh
                [label]   mnemonic   [operands]   [;comment]
                ```
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Podstawy składni - label
                ---
                Labele (etykiety) - nadają nazwy adresom pamięci, aby można było się do nich odnosić w łatwy sposób.
                
                ```x86asm
                section	.text
                global _start     
              
                _start: ; label
                   mov	edx,len       
                   mov	ecx,msg   
                   mov	ebx,1     
                   mov	eax,4     
                   int	0x80      
                
                   mov	eax,1     
                   int	0x80      

                section	.data
                msg db 'Hello, world!', 0xa ; label
                len equ $ - msg ; label
                ```
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Podstawy składni - mnemonic oraz operand
                ---
                Mnemonic - nazwa przypisana do instrukcji wykonywanej przez procesor.
                Operand - paramentry mnemonica.
                
                Przykładowe mnemonic'i:
                ```x86asm
                inc count ; Inkrementacja zmiennej pod adresem 'count'

                mov total, 48 ; Kopiuje liczbę pod adres 'total'

                add ah, bh ; Dodaje zawartość rejestru bh do ah i zapisuje w ah
                ```
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Segmenty pamięci
                ---
                Segmenty pamięci - **model pamięciowy** dzielący pamięć systemową
                na niezależne segmenty, do których możemy się dostać za 
                pomocą wskaźników znajdujących się w specjalnych rejestrach.  

                Segment vs Sekcja:  
                "The SECTION directive (SEGMENT is an exactly equivalent **synonym**)..."  
                <sup><sup><sup>NASM documentation</sup></sup></sup>

              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Segmenty pamięci - dane
                ---
                Segment danych - reprezentowany przez sekcje .data oraz .bss.  

                Sekcja .data - deklaruje statyczny region pamięci,
                w którym znajdują się zmienne globalne. Sekcja ta fizycznie
                występuje w pliku wykonywalnym - loader musi ją załadować
                do pamięci ram za nas.

                Sekcja .bss - deklaruje statyczny obszar pamięci,
                w którym pamięć jest wypełniona zerami. Lądują tutaj
                globalne zmienne niezainicjalizowane, lub zainicjalizowane
                zerami. Sekcja ta nie występuje również w pliku wykonywalnym - 
                loader wie, że przed wejściem do funkcji main należy zaalokować pamięć
                na tę sekcję i wypełnić ją zerami.
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Segmenty pamięci - kod
                ---
                Segment kodu - reprezentowany przez sekcję .text.  

                Sekcja .text - definiuje obszar w pamięci, w którym
                przechowywane są instrukcje programu. Ten obszar również
                jest statyczny.
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Segmenty pamięci - stos
                ---
                Segment stosu - zawiera tymczasowe wartości.
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Rejestry
                ---
                Rejestr – układ służący do przechowywania i odtwarzania informacji w postaci bitów. Na każdej pozycji rejestru przechowywany jest jeden bit informacji.
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Rejestry - ogólnego przeznaczenia
                ---
                Mamy 16 rejestrów ogólnego przeznaczenia. Możemy się odwoływać do wszystkich 64-bitów danego rejestru lub do ich części.
                Przechowują one następujące informacje:
                - argumenty dla operacji logicznych i arytmetycznych,
                - argumenty dla operacji dokonywanych na adresach,
                - wskaźniki na miejsca w pamięci.
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Rejestry - ogólnego przeznaczenia
                ---
                - **RSP** - Rejestr w którym przechowywany jest aktualny wskaźnik na ostati element dodany do stosu.
                - **RBP** - Rejestr w którym przechowywany jest wskaźnik, wykożystywany przy wywoływaniu funkcji.
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Rejestry - RIP
                ---
                **RIP** - Rejestr w którym przechowywany jest wskaźnik na następną instrukcję do wykonania.
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Rejestry - segmentowe
                ---
                Rejestry procesora stworzone aby przechowywać adresy początkowe segmentów pamięci.
                Rejestry:
                 - **CS** - segment kodu,
                 - **DS** - segment danych,
                 - **SS** - segment stosu,
                 - **ES**, **FS**, **GS** - dodatkowe segmenty danych.
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Rejestr - Flag
                ---
                Rejestry który jest używany, aby pokazać status oraz informacje kontrolne. Jest on 
                aktualizowany przez procesor po wykonaniu każdej instrukcji. Przykładowe flagi:
                - **ZF** - przetrzymuje informację czy wynikiem ostatniej operacji było 0,
                - **CF** - służy do wskazania czy poprzednia operacja zakończyła się przeniesieniem.
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Rejestr - XMM
                ---
                Rejestry o rozmiarze 128-bitów, przeznaczone do 64-bitowych oraz 32-bitowych operacji zmiennoprzecinkowych.
                Wspierają one również SIMD (Single Instruction Multiple Data). Nazwy rejestrów to xmm0 - xmm15.
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Wywołania systemowe
                ---
                Wywołania systemowe (syscalle) - podstawowy **interfejs**
                pomiędzy aplikacją a jądrem systemu.
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Wywołania systemowe - jak to robić?
                ---
                Aby skorzystać z wywołania systemowego na Linuxie należy:
                - Umieścić numer wywołania systemowego w rejestrze **EAX**
                - Umieścić argumenty wywołania systemowego w rejestrach **EBX**, **ECS**, ...
                - Wywołać przerwanie **int 80h**
                - Rezultat zazwyczaj jest zwracany do rejestru **EAX**
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Deklarowanie zmiennych - składnia
                ---
                Składnia deklarowania zmiennych wygląda następująco:
                ```x86asm
                [variable-name] define-directive initial-value [,initial-value]...
                ```
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Deklarowanie zmiennych - dyrektywy
                ---

                | Dyrektywa     | Ilość zaalokowanej pamięci (w bajtach) |
                | ------------- | ---:|
                | DB            |  1  |
                | DW            |  2  |
                | DD            |  4  |
                | DQ            |  8  |
                | DT            |  10 |
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Deklarowanie zmiennych niezainicjalozowanych
                ---

                | Dyrektywa     | Ilość zarezerwowanej pamięci (w bajtach) |
                | ------------- | ---:|
                | RESB          |  1  |
                | RESW          |  2  |
                | RESD          |  4  |
                | RESQ          |  8  |
                | REST          |  10 |
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Wielokrotne inicjalizacje
                ---
                Istnieją sytuacje, w których chcemy zainicjalizować 
                wiele bajtów tą samą wartością (np. tablice).
                Można wykorzystać do tego dyrektywę **TIMES**.

                ```x86asm
                arr TIMES 9 DW 0
                ```
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Definiowanie stałych
                ---
                Stałe w assembly możemy definiować na 3 sposoby,
                wykorzystując trzy różne dyrektywy:
                - EQU
                - %assign
                - %define
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Definiowanie stałych - dyrektywa EQU
                ---
                Dyrektywa EQU jest wykorzystywana do definiowania stałych.

                Składnia:
                ```x86asm
                CONSTANT_NAME EQU expression
                ```

                Stałe te można potem wykorzystywać w kodzie:
                ```x86asm
                mov eax, CONSTANT_NAME
                ```
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Definiowanie stałych - dyrektywa %assign
                ---
                Dyrektywa %assign jest również wykorzystywana do definiowania
                *stałych*, jednak pozwala na **redefinicję**.

                Składnia:
                ```x86asm
                %assign CONSTANT_NAME expression
                ```
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Definiowanie stałych - dyrektywa %define
                ---
                Dyrektywa %define jest bardzo podobna do #define znanego
                z języka C.

                Składnia:
                ```x86asm
                %define CONSTANT_NAME expression
                ```
              </textarea>
      </section>

      <section data-markdown style="text-align: justify;">
        <textarea data-template>
                ### Operatory logiczne
                ---
                Architektura IA-32 udostępnia nam również standardowe
                instrukcje logiczne:
                - AND
                - OR
                - XOR
                - TEST
                - NOT

                Składnia:
                ```x86asm
                LOGICAL_INSTRUCTION REGISTER/MEMORY REGISTER/MEMORY/IMMEDIATE
                ```
              </textarea>
      </section>

      <section data-markdown class="center">
        <textarea data-template>
              # Thank you!
            </textarea>
      </section>
    </div>
  </div>

  <script src="js/reveal.js"></script>
  <script>
    Reveal.initialize({
      progress: true,
      slideNumber: true,
      center: false,
      width: 960,
      height: 700,
      margin: 0.2,
      minScale: 0.1,
      maxScale: 2.5,
      dependencies: [
        { src: "plugin/markdown/marked.js" },
        { src: "plugin/markdown/markdown.js" },
        { src: "plugin/notes/notes.js", async: true },
        // { src: "plugin/highlight/highlight.js", async: true },
        {
          src: "plugin/highlight/highlight.js",
          async: true,
          callback: function () {
            hljs.initHighlightingOnLoad();
          }
        }
      ]
    });
  </script>
</body>

</html>